(* This file was generated by running coq-of-ocaml inefficient_sort.ml*)

Require Import CoqOfOCaml.CoqOfOCaml.
Require Import CoqOfOCaml.Settings.

Definition take {A : Set} (n : int) (xs : list A) : list A :=
  let fix aux {B : Set} (n : int) (xs : list B) (ys : list B) : list B :=
    if equiv_decb n 0 then
      ys
    else
      match xs with
      | [] => Stdlib.raise (Build_extensible "Boom" unit tt)
      | cons x xs' => aux (Z.sub n 1) xs' (cons x ys)
      end in
  List.rev (aux n xs nil).

Fixpoint drop {A : Set} (n : int) (xs : list A) : list A :=
  if equiv_decb n 0 then
    xs
  else
    match xs with
    | [] => Stdlib.raise (Build_extensible "Boom" unit tt)
    | cons _ xs' => drop (Z.sub n 1) xs'
    end.

Fixpoint merge {A : Set} (xs : list A) (ys : list A) (zs : list A) : list A :=
  match (xs, ys) with
  | ([], ys') => CoqOfOCaml.Stdlib.app zs ys'
  | (xs', []) => CoqOfOCaml.Stdlib.app zs xs'
  | (cons x xs', cons y ys') =>
    if CoqOfOCaml.Stdlib.lt x y then
      merge xs' (cons y ys') (CoqOfOCaml.Stdlib.app zs [ x ])
    else
      merge (cons x xs') ys' (CoqOfOCaml.Stdlib.app zs [ y ])
  end.

Definition partition {A : Set} (n : int) (xs : list A) : list A * list A :=
  let _left := take (Z.div n 2) xs in
  let _right := drop (Z.div n 2) xs in
  (_left, _right).

Fixpoint sort {A : Set} (xs : list A) : list A :=
  let n := CoqOfOCaml.List.length xs in
  if CoqOfOCaml.Stdlib.lt n 2 then
    xs
  else
    let '(_left, _right) := partition n xs in
    merge (sort _left) (sort _right) nil.

Definition xs : list int := [ 1; 10; 2; 9; 3; 8; 4; 7; 5; 6 ].

(** Init function; without side-effects in Coq *)
Definition init_module : unit := sort xs.
